docker run --name sql_server_container -e "ACCEPT_EULA=Y" -e "MSSQL_SA_PASSWORD=rahul@123" -p 1433:1433 -d mcr.microsoft.com/azure-sql-edge:latestdotnet --list-runtimes

1. How to install root certificate in database and use it for connection in code.
2. Path vs Query Parameter

Topic to complete
-------------------------------------
Minimal API
IEnumerable Vs IQueryable In LINQ

MVC API 
Logger          -------- start this-----------SERILOG----------DATADOG-----------------
Authentication  
-- ASP .NET CORE identity for Razor pages
-- Token based , Best for APIs and SPAs like angular 
    -- dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
    -- Add JwtBearer configuration in program.cs // this is to Authorize the token 
    -- expose and API to create token
Authorization
    -- Add [Authorize] for ApiController and .RequireAuthorization for the minimal endpoint.
    -- check the expiry of the token
    -- check the user id 
    -- Add custom middleware to validate the token and check the principal
Exception handling
    -- Global Exception
        -- Use IExceptionHandler Interface with TryHandleAsync 
        -- Use Custom Middleware to handle the exception.
Token Management
    -- Create token
    -- Verify token
    -- Refresh token
app.UseMiddleWare<>(); // app.UseAuthentication(); app.UseAuthorization(); are middleware added in program.cs
    -- done
Rate limiting Middleware -- NEXT
    -- theory 
Docker
    -- done
Allow CORS & effects 
    -- done 

OAuth2.0
    -- see .txt file
    -- OAuth 2.0 is an open-source authorization framework that allows a user to grant a third-party application limited access to their protected resources (like data on a website) without sharing their actual login credentials, such as their username and password. It works by issuing an access token to the third-party application, which the application uses to access the user's data on the resource server.

Fluent API && LINQ
    -- create notes
stored procedure -- NEXT 
entity framework -- NEXT 
what is database indexing 

performance optimization
    -- Asynchronous Programming
    ğŸ— ğŠğğ² ğ’ğ­ğ«ğšğ­ğğ ğ¢ğğ¬ ğ­ğ¨ ğğ¨ğ¨ğ¬ğ­ ğ€ğğˆ ğğğ«ğŸğ¨ğ«ğ¦ğšğ§ğœğ ğŸ’¡ 

        ğ”ğ¬ğ ğ‚ğšğœğ¡ğ¢ğ§ğ :
        Store frequently accessed data in memory so you donâ€™t have to repeatedly fetch it from the database or other slow sources. This drastically cuts down on response time.

        ğŒğ¢ğ§ğ¢ğ¦ğ¢ğ³ğ ğğšğ²ğ¥ğ¨ğšğ ğ’ğ¢ğ³ğ:
        Send only the necessary data in responses. Avoid sending large, unneeded chunks of data by filtering fields or compressing the payload, which reduces bandwidth usage and speeds up responses.

        ğ”ğ¬ğ ğ€ğ¬ğ²ğ§ğœğ¡ğ«ğ¨ğ§ğ¨ğ®ğ¬ ğğ«ğ¨ğœğğ¬ğ¬ğ¢ğ§ğ :
        Use asynchronous methods for tasks that donâ€™t need an immediate response (like sending emails or processing large data sets). This keeps the API responsive while the heavy work happens in the background.

        ğ‹ğ¨ğšğ ğğšğ¥ğšğ§ğœğ¢ğ§ğ :
        Distribute incoming API requests across multiple servers to ensure no single server is overloaded. This improves availability and handles more traffic efficiently.

        ğğ©ğ­ğ¢ğ¦ğ¢ğ³ğ ğƒğšğ­ğš ğ…ğ¨ğ«ğ¦ğšğ­ğ¬:
        Use lightweight data formats like JSON or Protocol Buffers instead of XML. Smaller data formats reduce the time spent parsing and transmitting data.

        ğ‚ğ¨ğ§ğ§ğğœğ­ğ¢ğ¨ğ§ ğğ¨ğ¨ğ¥ğ¢ğ§ğ :
        Reuse existing connections to the database or other services rather than opening a new one for each request. Connection pooling significantly reduces the overhead of establishing connections.

        ğ”ğ¬ğ ğ‚ğ¨ğ§ğ­ğğ§ğ­ ğƒğğ¥ğ¢ğ¯ğğ«ğ² ğğğ­ğ°ğ¨ğ«ğ¤ğ¬ (ğ‚ğƒğğ¬):
        For APIs serving static content (like images or scripts), use CDNs to deliver content faster by caching it closer to the userâ€™s location, reducing latency.

        ğˆğ¦ğ©ğ¥ğğ¦ğğ§ğ­ ğ€ğğˆ ğ†ğšğ­ğğ°ğšğ²:
        An API Gateway can help routing requests, handling authentication, rate limiting, and caching. By offloading these tasks from your API, you can improve its overall performance.

        ğ€ğ¯ğ¨ğ¢ğ ğğ¯ğğ«ğŸğğ­ğœğ¡ğ¢ğ§ğ  ğšğ§ğ ğ”ğ§ğğğ«ğŸğğ­ğœğ¡ğ¢ğ§ğ :
        Design your API endpoints to return just the right amount of data. GraphQL, for example, allows clients to request exactly what they need, avoiding overfetching and underfetching issues common in REST APIs.

Cache the API request response
    -- In Memory Caching
    -- Output Caching REDIS

CI/CD Pipeline
Kubernetes 
    - It is used to manage the containers, if one container is down then create a new one and kill the previous.
    - It also provides load balancing 
    - similar like docker compose up
    - try the implementation
SYSTEM Design
Microservices Architecture
Load Balancer and it's algorithms. 
Casandra DB speciality
basic authentication

2. Middleware
You've already been using middleware without maybe realizing it (like app.UseRouting() or app.UseHttpsRedirection()). Understanding it fully is essential for building custom logic into the request pipeline.
What it is: Middleware is a component that sits in an application's request pipeline to handle requests and responses. It's a key part of how ASP.NET Core processes HTTP traffic.
Custom Middleware: You should learn how to create your own middleware to handle cross-cutting concerns like logging requests, handling exceptions, or performing custom authentication logic.



Cloud topics
---------------------------------
Cloud, DevOps, and Infrastructure
Containerization and Orchestration: Master Docker for containerizing applications and Kubernetes for orchestrating them at scale. Understand concepts like Helm charts for deployment and managing secrets.

Serverless Architecture: Learn to build event-driven backend services using Azure Functions or AWS Lambda. Understand the trade-offs and best practices for serverless.

Infrastructure as Code (IaC): Gain experience with tools like Terraform or Bicep to define and manage cloud infrastructure programmatically.

CI/CD Pipeline Mastery: Go beyond simple build/deploy steps. Focus on building robust pipelines that include automated testing, security scanning, and blue/green or canary deployments.

Advance
-----------------------------
.NET Internals: Understand how the Garbage Collector (GC), Just-In-Time (JIT) compiler, and runtime host work. This knowledge is invaluable for advanced debugging and performance tuning.
Customization of ASP.NET Core: Develop custom middleware, filters, and endpoint conventions to extend the ASP.NET Core pipeline in sophisticated ways.



Complex problems:
--------------------------
1. Find the most popular book(s): 
This operation involves joining Book with a table that tracks checkouts or loans. You'd group the results by BookID and count the number of checkouts to find the book with the highest count.

SQL

SELECT B.Title, B.ISBN, COUNT(L.LoanID) AS NumberOfLoans
FROM Books AS B
JOIN Loans AS L ON B.BookID = L.BookID
GROUP BY B.BookID
ORDER BY NumberOfLoans DESC
LIMIT 5;

2. Identify overdue books and the members who have them: 
This requires joining Book with Loan and Member tables. The condition would check if the loan's return date is null and if the due date is in the past.

SQL

SELECT M.MemberName, B.Title, L.DueDate
FROM Loans AS L
JOIN Members AS M ON L.MemberID = M.MemberID
JOIN Books AS B ON L.BookID = B.BookID
WHERE L.ReturnDate IS NULL AND L.DueDate < CURRENT_DATE;

3. Find authors who have not published a book in the last five years: 
This involves using a subquery or a LEFT JOIN. You'd find all authors, then filter out the ones whose most recent book was published within the last five years.

SQL

SELECT A.AuthorName
FROM Authors AS A
WHERE A.AuthorID NOT IN (
    SELECT B.AuthorID
    FROM Books AS B
    WHERE B.PublicationYear >= YEAR(CURRENT_DATE) - 5
);

4. Find members who have read books from more than one genre: 
This involves joining Member, Loan, and Book tables, then grouping by MemberID and counting the distinct genres they've borrowed.

SQL

SELECT M.MemberName, COUNT(DISTINCT B.Genre) AS NumberOfGenres
FROM Members AS M
JOIN Loans AS L ON M.MemberID = L.MemberID
JOIN Books AS B ON L.BookID = B.BookID
GROUP BY M.MemberID
HAVING COUNT(DISTINCT B.Genre) > 1; 
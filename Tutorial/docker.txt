When to use dotnet publish:
----------------------------
Simple, self-contained deployments:
When deploying to a known and controlled environment where the target machine has the necessary .NET runtime installed, dotnet publish can create a self-contained executable or framework-dependent deployment. 
This is suitable for straightforward deployments to a single server or a small number of machines.
Minimal overhead:
If resource efficiency and avoiding the overhead of containerization are critical, dotnet publish directly packages the application without the additional layer of a container runtime.
Traditional server deployments:
For applications deployed directly onto virtual machines or physical servers without container orchestration, dotnet publish provides the necessary deployment package.

When to use Docker:
--------------------
Containerization and isolation:
When application isolation, portability, and consistent environments are priorities, Docker containers encapsulate the application and its dependencies, ensuring it runs identically across different environments (development, testing, production).
Microservices and distributed systems:
Docker is well-suited for deploying microservices architectures, where individual services can be containerized and managed independently, facilitating scalability and resilience.
CI/CD pipelines:
Docker integrates seamlessly with Continuous Integration/Continuous Delivery (CI/CD) pipelines, enabling automated building, testing, and deployment of containerized applications.
Scalability and orchestration:
When dynamic scaling and orchestration of applications are required, Docker containers can be managed by container orchestration platforms like Kubernetes, allowing for efficient resource utilization and high availability.
Cloud-native deployments:
Docker is a fundamental technology in cloud-native application development and deployment, enabling easy deployment to cloud platforms that support container services.


Definition: 
-----------
Docker is an open-source platform designed to simplify the process of building, deploying, and running applications using containerization. 
It allows developers to package an application and all its dependencies (code, runtime, system tools, libraries, and settings) into a standardized unit called a "Docker container." 

For this we have to create Dockerfile.
In dockerfile we have to load all files and then run the command.




how to know your application's environemnt in docker run.
open a shell inside docker using: docker exec -it <container_id> sh. To get the id, run docker ps
run echo $ASPNETCORE_ENVIRONMENT
If nothing prints → it defaults to Production.


issue while running app with docker where sqlserver was running on docker.

Option 1: Connect via host.docker.internal

If SQL Server is still exposed on port 1433 to the host, your WebApp container can connect to the host using:

"ConnectionStrings": {
  "DefaultConnection": "Server=host.docker.internal,1433;Database=MyDb;User Id=sa;Password=Your_password123;TrustServerCertificate=True;"
}

Option 2.
Create a network:

docker network create mynetwork


Start SQL Server in that network:

docker run -e "ACCEPT_EULA=Y" -e "SA_PASSWORD=Your_password123" \
  --network mynetwork --name sqlserver -d mcr.microsoft.com/mssql/server:2022-latest


Run WebApp in the same network:

docker run -p 8080:8080 --network mynetwork mywebapp


Use connection string with container name:

"ConnectionStrings": {
  "DefaultConnection": "Server=sqlserver,1433;Database=MyDb;User Id=sa;Password=Your_password123;TrustServerCertificate=True;"
}


Here, Docker’s internal DNS resolves sqlserver → SQL Server container.